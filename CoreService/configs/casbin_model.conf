# Casbin Model Configuration for Magellon CoreService
# This defines the authorization model (RBAC with resource hierarchy)

[request_definition]
# Request: (subject, object, action)
# subject = user_id (UUID as string)
# object = resource identifier (e.g., "msession:123", "action:export", "navigation:/admin")
# action = operation (e.g., "read", "write", "delete", "create", "execute", "navigate")
r = sub, obj, act

[policy_definition]
# Policy: (subject, object, action, effect)
# subject = user_id or role_name
# object = resource identifier or wildcard pattern
# action = operation or wildcard (*)
# effect = "allow" or "deny"
p = sub, obj, act, eft

[role_definition]
# g = role inheritance (user -> role)
# user_id -> role_name
g = _, _

# g2 = resource hierarchy (optional, for future use)
# resource -> parent_resource
g2 = _, _

[policy_effect]
# Effect: Allow if there's at least one allow and no deny
# This implements "deny overrides allow" policy
e = some(where (p.eft == allow)) && !some(where (p.eft == deny))

[matchers]
# Matcher: Define how to match request with policies
#
# Rules:
# 1. If user has role AND role has permission for resource AND action matches -> allow
# 2. If user has role AND role has wildcard permission for resource -> allow
# 3. Wildcard support: "msession:*" matches all msession resources
#
# Pattern matching:
# - g(r.sub, p.sub): Check if user has the role
# - r.obj == p.obj: Exact resource match
# - globMatch(r.obj, p.obj): Wildcard match (e.g., "msession:*" matches "msession:123")
# - r.act == p.act: Exact action match
# - p.act == "*": Wildcard action (any action allowed)
#
# Note: Using globMatch instead of keyMatch2 because keyMatch2 treats ':' as special character

m = g(r.sub, p.sub) && (r.obj == p.obj || globMatch(r.obj, p.obj)) && (r.act == p.act || p.act == "*")
